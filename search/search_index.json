{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"getversion \u00b6 Get the version number of any python module or package, reliably. Do you need a reliable way to get a version number corresponding to a python object ? getversion was made for this. It combines the best existing strategies to cover the broadest possible set of cases. It is easily extensible so that adding new strategies is extremely easy. Do not hesitate to open an issue or a PR if the current 5 built-in strategies do not work for you! If you wish to know why \"yet another package\" is necessary, have a look at the motivation section . Installing \u00b6 > pip install getversion Usage \u00b6 a- Already imported \u00b6 from getversion import get_module_version # Get the version of an imported module from xml import dom version , details = get_module_version ( dom ) print ( version ) yields 3 .7.3.final.0 Why was this version found ? You can understand it from the details : > print ( details ) Version '3.7.3.final.0' found for module 'xml.dom' by strategy 'get_builtin_module_version' , after the following failed attempts: - Attempts for module 'xml.dom' : - <get_module_version_attr>: module 'xml.dom' has no attribute '__version__' - Attempts for module 'xml' : - <get_module_version_attr>: module 'xml' has no attribute '__version__' - <get_version_using_pkgresources>: Invalid version number: None - <get_builtin_module_version>: SUCCESS: 3 .7.3.final.0 b- Not yet imported \u00b6 TODO Motivation \u00b6 Packages, modules, dists \u00b6 In python: - a module is a file ending with .py , containing some symbols. - a package is a folder containing a __init__.py file, as well as any number of subpackages and submodules. See also this explanation . When you distribute python code, you distribute either a single module, or a single package. The name of this \"root\" module or package is the first name that appears in an import: import xml # root package 'xml' import xml.dom # subpackage 'dom' of pkg 'xml' import xml.dom.minidom # submodule 'minidom' of pkg 'xml.dom' See distributing python modules . Why another package ? \u00b6 Version numbers in python can be in very different places depending on the case: for modules and packages , on the optional __version__ attribute as recommended by PEP396 . It should be considered inherited by subpackages and submodules by default if they do not have the attribute. for distributed modules and packages , on the Version Metadata field as indicated by PEP345 , that is located: for built wheels distributions ( PEP427 ), on the dist-info directory , but also in the dist-info folder name for built eggs distributions (legacy format from setuptools ), on the egg-info directory , but is also in the egg-info folder name finally, for built-in modules and packages , the default version should be inherited from the python system version except if overridden In addition to this, at runtime (when you need that version number), packages and modules can be already imported or not built and pip-installed (in debug mode or not), or simply added to the PYTHON PATH ( sys.path ) non-built and added to the PYTHON PATH ( sys.path ) This variety of settings makes it very difficult for existing solutions to tackle all aspects of this problem. pkg_resources is probably the best way to get it as of today (like this ), but does not work for example when a package is an unzipped wheel added to the PYTHON PATH. It also does not support built-in modules. Main features / benefits \u00b6 Get module and package version easily : a single method will get you what you need, whatever the variety of ways needed to get the information Support for multiple strategies : built-in modules, PEP396/version, setuptools/ pkg_resources , PEP427/wheel, setuptools/eggs, git... See Also \u00b6 Concerning the strategies: stdlib_list for built-in modules detection PEP396/__version__ PEP314/Metadata pkg_resources documentation and PEP365 PEP427/wheel setuptools_scm Discussion on PyPa: here . Other attempts to reach the same target: app_version importlib_metadata pkginfo read_version Package versioning best practices \u00b6 If your project uses git, I would recommend the following: in __init__.py try: # -- Distribution mode -- # import from _version.py generated by setuptools_scm during release from ._version import version as __version__ except ImportError: # -- Source mode -- # use setuptools_scm to get the current version from src using git from setuptools_scm import get_version as _gv from os import path as _path __version__ = _gv(_path.join(_path.dirname(__file__), _path.pardir)) then, EITHER in setup.py : setup( ... use_scm_version={'write_to': '%s/_version.py' % <pkgname>} ) OR when you wish to create releases, after git-tagging your project and before publishing it, do from setuptools_scm import get_version get_version('.', write_to='<pkg_name>/_version.py') for example in your continuous integration engine: python -c \"from setuptools_scm import get_version;get_version('.', write_to='<pkg_name>/_version.py')\" Note: the above was inspired by this post and this issue . Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-getversion","title":"Home"},{"location":"#getversion","text":"Get the version number of any python module or package, reliably. Do you need a reliable way to get a version number corresponding to a python object ? getversion was made for this. It combines the best existing strategies to cover the broadest possible set of cases. It is easily extensible so that adding new strategies is extremely easy. Do not hesitate to open an issue or a PR if the current 5 built-in strategies do not work for you! If you wish to know why \"yet another package\" is necessary, have a look at the motivation section .","title":"getversion"},{"location":"#installing","text":"> pip install getversion","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#a-already-imported","text":"from getversion import get_module_version # Get the version of an imported module from xml import dom version , details = get_module_version ( dom ) print ( version ) yields 3 .7.3.final.0 Why was this version found ? You can understand it from the details : > print ( details ) Version '3.7.3.final.0' found for module 'xml.dom' by strategy 'get_builtin_module_version' , after the following failed attempts: - Attempts for module 'xml.dom' : - <get_module_version_attr>: module 'xml.dom' has no attribute '__version__' - Attempts for module 'xml' : - <get_module_version_attr>: module 'xml' has no attribute '__version__' - <get_version_using_pkgresources>: Invalid version number: None - <get_builtin_module_version>: SUCCESS: 3 .7.3.final.0","title":"a- Already imported"},{"location":"#b-not-yet-imported","text":"TODO","title":"b- Not yet imported"},{"location":"#motivation","text":"","title":"Motivation"},{"location":"#packages-modules-dists","text":"In python: - a module is a file ending with .py , containing some symbols. - a package is a folder containing a __init__.py file, as well as any number of subpackages and submodules. See also this explanation . When you distribute python code, you distribute either a single module, or a single package. The name of this \"root\" module or package is the first name that appears in an import: import xml # root package 'xml' import xml.dom # subpackage 'dom' of pkg 'xml' import xml.dom.minidom # submodule 'minidom' of pkg 'xml.dom' See distributing python modules .","title":"Packages, modules, dists"},{"location":"#why-another-package","text":"Version numbers in python can be in very different places depending on the case: for modules and packages , on the optional __version__ attribute as recommended by PEP396 . It should be considered inherited by subpackages and submodules by default if they do not have the attribute. for distributed modules and packages , on the Version Metadata field as indicated by PEP345 , that is located: for built wheels distributions ( PEP427 ), on the dist-info directory , but also in the dist-info folder name for built eggs distributions (legacy format from setuptools ), on the egg-info directory , but is also in the egg-info folder name finally, for built-in modules and packages , the default version should be inherited from the python system version except if overridden In addition to this, at runtime (when you need that version number), packages and modules can be already imported or not built and pip-installed (in debug mode or not), or simply added to the PYTHON PATH ( sys.path ) non-built and added to the PYTHON PATH ( sys.path ) This variety of settings makes it very difficult for existing solutions to tackle all aspects of this problem. pkg_resources is probably the best way to get it as of today (like this ), but does not work for example when a package is an unzipped wheel added to the PYTHON PATH. It also does not support built-in modules.","title":"Why another package ?"},{"location":"#main-features-benefits","text":"Get module and package version easily : a single method will get you what you need, whatever the variety of ways needed to get the information Support for multiple strategies : built-in modules, PEP396/version, setuptools/ pkg_resources , PEP427/wheel, setuptools/eggs, git...","title":"Main features / benefits"},{"location":"#see-also","text":"Concerning the strategies: stdlib_list for built-in modules detection PEP396/__version__ PEP314/Metadata pkg_resources documentation and PEP365 PEP427/wheel setuptools_scm Discussion on PyPa: here . Other attempts to reach the same target: app_version importlib_metadata pkginfo read_version","title":"See Also"},{"location":"#package-versioning-best-practices","text":"If your project uses git, I would recommend the following: in __init__.py try: # -- Distribution mode -- # import from _version.py generated by setuptools_scm during release from ._version import version as __version__ except ImportError: # -- Source mode -- # use setuptools_scm to get the current version from src using git from setuptools_scm import get_version as _gv from os import path as _path __version__ = _gv(_path.join(_path.dirname(__file__), _path.pardir)) then, EITHER in setup.py : setup( ... use_scm_version={'write_to': '%s/_version.py' % <pkgname>} ) OR when you wish to create releases, after git-tagging your project and before publishing it, do from setuptools_scm import get_version get_version('.', write_to='<pkg_name>/_version.py') for example in your continuous integration engine: python -c \"from setuptools_scm import get_version;get_version('.', write_to='<pkg_name>/_version.py')\" Note: the above was inspired by this post and this issue .","title":"Package versioning best practices"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-getversion","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 1.0.2 - fixed version strings in case of prerelease tags \u00b6 Prerelease version strings such as 1.0.0-rc1 were incorrectly returned as 1.0.0rc1 (without dash) because of an issue with setuptools_scm due to pkg_resources removing the dash of prerelease versions. Fixes #10 1.0.1 - bugfix \u00b6 Fixed version resolution using pkg_resources . Fixed #9 1.0.0 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file. Fixes #8 0.5.8 - better error message in case git is unavailable \u00b6 Improved readability of setuptools_scm related outputs: Now an explicit message states when git command is not available. Fixed #6 Now an explicit message states when setuptools_scm is not installed. Fixed #7 . 0.5.7 - minor setup.py improvement \u00b6 Now explicitly setting the zip_safe flag in setup.py to avoid ply being downloaded. From #5 0.5.6 - fixed setup.py classifiers \u00b6 It was incorrectly refering to this project as related to testing. 0.5.5 - Own __version__ was incorrect \u00b6 Fixed #4 . 0.5.4 - Fixed bug in case of package both installed and in the path \u00b6 Fixed bug (incorrect version number) happening when a package is both installed and available on python path. This typically happens when a developer is working on a new version of a package while an older version is already installed. Fixes #3 . 0.5.3 - Self __version__ \u00b6 __version__ should now be available on the distributed getversion package. 0.5.0 - First public version \u00b6 Simplified design: now a single get_module_version function is the entry point and compiles 4 strategies: __version__ attribute built-in module using stdlib_list unzipped wheel & unzipped egg git scm using setuptools_scm 0.4.0 - extracted \u00b6 First version extracted from private industrial project. Most important legacy changelog entries for reference: Fixed a version detection bug happening when there is a version conflict in the pip environment (for example when package A depends on package B with version <=1.0.0 , and the found B has version 1.1.0 ). The version is now correctly detected even if it is a source project and an old egg-info folder with wrong version is present in filesystem. Bug fix: reading version from unzipped wheel Various bug fixes in module version handling Improved version detection algorithm when relying on git, in get_pkg_version_from_module new method get_pkg_version_from_module in utils_modules.py new module utils_version_handling.py for everything related to versions.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#102-fixed-version-strings-in-case-of-prerelease-tags","text":"Prerelease version strings such as 1.0.0-rc1 were incorrectly returned as 1.0.0rc1 (without dash) because of an issue with setuptools_scm due to pkg_resources removing the dash of prerelease versions. Fixes #10","title":"1.0.2 - fixed version strings in case of prerelease tags"},{"location":"changelog/#101-bugfix","text":"Fixed version resolution using pkg_resources . Fixed #9","title":"1.0.1 - bugfix"},{"location":"changelog/#100-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file. Fixes #8","title":"1.0.0 - packaging improvements"},{"location":"changelog/#058-better-error-message-in-case-git-is-unavailable","text":"Improved readability of setuptools_scm related outputs: Now an explicit message states when git command is not available. Fixed #6 Now an explicit message states when setuptools_scm is not installed. Fixed #7 .","title":"0.5.8 - better error message in case git is unavailable"},{"location":"changelog/#057-minor-setuppy-improvement","text":"Now explicitly setting the zip_safe flag in setup.py to avoid ply being downloaded. From #5","title":"0.5.7 - minor setup.py improvement"},{"location":"changelog/#056-fixed-setuppy-classifiers","text":"It was incorrectly refering to this project as related to testing.","title":"0.5.6 - fixed setup.py classifiers"},{"location":"changelog/#055-own-__version__-was-incorrect","text":"Fixed #4 .","title":"0.5.5 - Own __version__ was incorrect"},{"location":"changelog/#054-fixed-bug-in-case-of-package-both-installed-and-in-the-path","text":"Fixed bug (incorrect version number) happening when a package is both installed and available on python path. This typically happens when a developer is working on a new version of a package while an older version is already installed. Fixes #3 .","title":"0.5.4 - Fixed bug in case of package both installed and in the path"},{"location":"changelog/#053-self-__version__","text":"__version__ should now be available on the distributed getversion package.","title":"0.5.3 - Self __version__"},{"location":"changelog/#050-first-public-version","text":"Simplified design: now a single get_module_version function is the entry point and compiles 4 strategies: __version__ attribute built-in module using stdlib_list unzipped wheel & unzipped egg git scm using setuptools_scm","title":"0.5.0 - First public version"},{"location":"changelog/#040-extracted","text":"First version extracted from private industrial project. Most important legacy changelog entries for reference: Fixed a version detection bug happening when there is a version conflict in the pip environment (for example when package A depends on package B with version <=1.0.0 , and the found B has version 1.1.0 ). The version is now correctly detected even if it is a source project and an old egg-info folder with wrong version is present in filesystem. Bug fix: reading version from unzipped wheel Various bug fixes in module version handling Improved version detection algorithm when relying on git, in get_pkg_version_from_module new method get_pkg_version_from_module in utils_modules.py new module utils_version_handling.py for everything related to versions.","title":"0.4.0 - extracted"},{"location":"long_description/","text":"python-getversion \u00b6 Get the version number of any python module or package, reliably. The documentation for users is available here: https://smarie.github.io/python-getversion/ A readme for developers is available here: https://github.com/smarie/python-getversion","title":"python-getversion"},{"location":"long_description/#python-getversion","text":"Get the version number of any python module or package, reliably. The documentation for users is available here: https://smarie.github.io/python-getversion/ A readme for developers is available here: https://github.com/smarie/python-getversion","title":"python-getversion"}]}